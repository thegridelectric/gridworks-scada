<!DOCTYPE html>
<html>
<head>
    <title>Relay Control</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Fixed Status Bar -->
    <div id="status" style="position: fixed; top: 0; left: 0; right: 0; background-color: var(--card-background); border-bottom: 1px solid var(--border-color); padding: 8px 20px; display: flex; justify-content: space-between; align-items: center; z-index: 1000;">
        <div id="status-left">Connecting...</div>
        <div id="status-right"></div>
    </div>
    
    <!-- Main Content with top padding to account for fixed header -->
    <div style="padding-top: 60px;">
        <h1 style="text-align: center; margin-top: 30px; margin-bottom: 40px;">Dashboard</h1>
        
        <!-- System Monitoring Tables -->
        <div id="monitoring-tables" style="max-width: 1400px; margin: 20px auto 40px auto; display: flex; flex-wrap: wrap; gap: 30px; justify-content: center;">
            <!-- Thermostats and Hot Water Table -->
            <div>
                <table id="thermostat-table" style="border: 1px solid var(--border-color); border-collapse: collapse; border-radius: 0.25rem; background-color: var(--card-background); margin: 0 auto;">
                    <thead>
                        <tr style="background-color: #f0f0f0;">
                            <th style="border: 1px solid var(--border-color); padding: 8px; text-align: left; font-weight: bold;">Thermostats</th>
                            <th style="border: 1px solid var(--border-color); padding: 8px; text-align: left; font-weight: bold;">Setpoint</th>
                            <th style="border: 1px solid var(--border-color); padding: 8px; text-align: left; font-weight: bold;">Temperature</th>
                            <th style="border: 1px solid var(--border-color); padding: 8px; text-align: left; font-weight: bold;">State</th>
                        </tr>
                    </thead>
                    <tbody id="thermostat-tbody">
                        <tr>
                            <td style="border: 1px solid var(--border-color); padding: 8px;">Loading...</td>
                            <td style="border: 1px solid var(--border-color); padding: 8px;">Loading...</td>
                            <td style="border: 1px solid var(--border-color); padding: 8px;">Loading...</td>
                            <td style="border: 1px solid var(--border-color); padding: 8px;">Loading...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <!-- HP Power Table -->
            <div>
                <table id="hp-power-table" style="border: 1px solid var(--border-color); border-collapse: collapse; border-radius: 0.25rem; background-color: var(--card-background); margin: 0 auto;">
                    <thead>
                        <tr style="background-color: #f0f0f0;">
                            <th style="border: 1px solid var(--border-color); padding: 8px; text-align: left; font-weight: bold;">Heat pump</th>
                            <th style="border: 1px solid var(--border-color); padding: 8px; text-align: left; font-weight: bold;">kW</th>
                        </tr>
                    </thead>
                    <tbody id="hp-power-tbody">
                        <tr>
                            <td style="border: 1px solid var(--border-color); padding: 8px;">Loading...</td>
                            <td style="border: 1px solid var(--border-color); padding: 8px;">Loading...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <!-- Pump Table -->
            <div>
                <table id="pump-table" style="border: 1px solid var(--border-color); border-collapse: collapse; border-radius: 0.25rem; background-color: var(--card-background); margin: 0 auto;">
                    <thead>
                        <tr style="background-color: #f0f0f0;">
                            <th style="border: 1px solid var(--border-color); padding: 8px; text-align: left; font-weight: bold;">Pumps</th>
                            <th style="border: 1px solid var(--border-color); padding: 8px; text-align: left; font-weight: bold;">GPM</th>
                            <th style="border: 1px solid var(--border-color); padding: 8px; text-align: left; font-weight: bold;">W</th>
                        </tr>
                    </thead>
                    <tbody id="pump-tbody">
                        <tr>
                            <td style="border: 1px solid var(--border-color); padding: 8px;">Loading...</td>
                            <td style="border: 1px solid var(--border-color); padding: 8px;">Loading...</td>
                            <td style="border: 1px solid var(--border-color); padding: 8px;">Loading...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
        
        <!-- System State Information -->
        <div id="system-state" style="text-align: center; max-width: 1000px; margin: 20px auto 100px auto; background-color: var(--card-background); border: 1px solid var(--border-color); border-radius: 0.25rem; padding: 20px;">
            <div id="hp-state" style="font-size: 18px; font-weight: 600; color: var(--text-color);"></div>
            <div id="storage-state" style="font-size: 18px; font-weight: 600; color: var(--text-color);"></div>
            <div id="combined-state" style="font-size: 20px; font-weight: 700; color: var(--text-color);">Determining state...</div>
        </div>

        <!-- System Diagram -->
        <div id="system-diagram" style="text-align: center; max-width: 1200px; margin: 20px auto 400px auto; background-color: var(--card-background); border: 1px solid var(--border-color); border-radius: 0.25rem; padding: 30px;">
            <h2 style="margin-top: 0; margin-bottom: 30px; color: var(--text-color);">System Overview</h2>
            
            <!-- TEMPORARY: Testing dropdown for system modes -->
            <div style="margin-bottom: 20px;">
                <label for="testModeSelect" style="color: var(--text-color); font-family: Montserrat, sans-serif; font-size: 14px; margin-right: 10px;">Test Mode:</label>
                <select id="testModeSelect" style="padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; background: var(--bg-color); color: var(--text-color); font-family: Montserrat, sans-serif; font-size: 14px;">
                    <option value="HpOnStoreOff">HpOnStoreOff</option>
                    <option value="HpOnStoreCharge">HpOnStoreCharge</option>
                    <option value="HpOffStoreDischarge">HpOffStoreDischarge</option>
                    <option value="HpOffStoreOff">HpOffStoreOff</option>
                    <option value="Auto">Auto (Real System State)</option>
                </select>
            </div>
            <svg id="diagram-svg" viewBox="0 0 1000 500" style="width: 100%; height: auto; max-width: 1000px;">
                <defs>
                    <!-- Flow pattern for HpOffStoreDischarge top horizontal pipe -->
                    <pattern id="flowPattern" x="0" y="0" width="90" height="15" patternUnits="userSpaceOnUse">
                        <rect width="90" height="15" fill="#4CAF50"/>
                        <rect x="0" y="0" width="15" height="15" fill="#66BB6A"/>
                        <rect x="30" y="0" width="15" height="15" fill="#66BB6A"/>
                        <rect x="60" y="0" width="15" height="15" fill="#66BB6A"/>
                        <animateTransform
                            attributeName="patternTransform"
                            type="translate"
                            values="0 0; 90 0"
                            dur="1.2s"
                            repeatCount="indefinite"/>
                    </pattern>
                    
                    <!-- Flow pattern for HpOffStoreDischarge vertical pipe (upward flow) -->
                    <pattern id="verticalFlowPattern" x="0" y="0" width="15" height="90" patternUnits="userSpaceOnUse">
                        <rect width="15" height="90" fill="#4CAF50"/>
                        <rect x="0" y="0" width="15" height="15" fill="#66BB6A"/>
                        <rect x="0" y="30" width="15" height="15" fill="#66BB6A"/>
                        <rect x="0" y="60" width="15" height="15" fill="#66BB6A"/>
                        <animateTransform
                            attributeName="patternTransform"
                            type="translate"
                            values="0 0; 0 -90"
                            dur="1.2s"
                            repeatCount="indefinite"/>
                    </pattern>
                    
                    <!-- Flow pattern for HpOffStoreDischarge vertical pipe (downward flow) -->
                    <pattern id="verticalDownFlowPattern" x="0" y="0" width="15" height="90" patternUnits="userSpaceOnUse">
                        <rect width="15" height="90" fill="#4CAF50"/>
                        <rect x="0" y="0" width="15" height="15" fill="#66BB6A"/>
                        <rect x="0" y="30" width="15" height="15" fill="#66BB6A"/>
                        <rect x="0" y="60" width="15" height="15" fill="#66BB6A"/>
                        <animateTransform
                            attributeName="patternTransform"
                            type="translate"
                            values="0 0; 0 90"
                            dur="1.2s"
                            repeatCount="indefinite"/>
                    </pattern>
                    
                    <!-- Flow pattern for HpOffStoreDischarge horizontal pipe (leftward flow) -->
                    <pattern id="leftFlowPattern" x="0" y="0" width="90" height="15" patternUnits="userSpaceOnUse">
                        <rect width="90" height="15" fill="#4CAF50"/>
                        <rect x="0" y="0" width="15" height="15" fill="#66BB6A"/>
                        <rect x="30" y="0" width="15" height="15" fill="#66BB6A"/>
                        <rect x="60" y="0" width="15" height="15" fill="#66BB6A"/>
                        <animateTransform
                            attributeName="patternTransform"
                            type="translate"
                            values="0 0; -90 0"
                            dur="1.2s"
                            repeatCount="indefinite"/>
                    </pattern>
                </defs>
                <!-- Heat pump (left) -->
                <rect x="20" y="50" width="120" height="200" rx="10" fill="#666"/>
                <text x="80" y="150" text-anchor="middle" fill="white" font-family="Montserrat, sans-serif" font-size="14" font-weight="600">Heat pump</text>
                <text id="hp-lift" x="80" y="170" text-anchor="middle" fill="white" font-family="Montserrat, sans-serif" font-size="12" font-weight="600">Lift: -Â°F</text>
                
                <!-- Buffer (right) -->
                <rect x="860" y="50" width="120" height="200" rx="10" fill="transparent"/>
                <!-- Buffer sections -->
                <path id="buffer-section1" d="M 860,60 Q 860,50 870,50 L 970,50 Q 980,50 980,60 L 980,116 L 860,116 Z" fill="#444"/>
                <rect id="buffer-section2" x="860" y="116" width="120" height="66" fill="#444"/>
                <path id="buffer-section3" d="M 860,182 L 980,182 L 980,240 Q 980,250 970,250 L 870,250 Q 860,250 860,240 Z" fill="#444"/>
                <text id="buffer-depth1" x="920" y="90" text-anchor="middle" fill="white" font-family="Montserrat, sans-serif" font-size="12" font-weight="600">-</text>
                <text id="buffer-depth2" x="920" y="156" text-anchor="middle" fill="white" font-family="Montserrat, sans-serif" font-size="12" font-weight="600">-</text>
                <text id="buffer-depth3" x="920" y="222" text-anchor="middle" fill="white" font-family="Montserrat, sans-serif" font-size="12" font-weight="600">-</text>
                <text x="920" y="270" text-anchor="middle" fill="var(--text-color)" font-family="Montserrat, sans-serif" font-size="14" font-weight="600">Buffer</text>
                
                <!-- House (bottom right, left of buffer) -->
                <rect x="660" y="280" width="120" height="200" rx="10" fill="#666"/>
                <text x="720" y="385" text-anchor="middle" fill="white" font-family="Montserrat, sans-serif" font-size="14" font-weight="600">House</text>
                <text id="house-drop" x="720" y="405" text-anchor="middle" fill="white" font-family="Montserrat, sans-serif" font-size="12" font-weight="600">Drop: -Â°F</text>
                
                <!-- Tank 3 (bottom left) -->
                <rect x="200" y="280" width="120" height="200" rx="10" fill="transparent"/>
                <!-- Tank 3 sections -->
                <path id="tank3-section1" d="M 200,290 Q 200,280 210,280 L 310,280 Q 320,280 320,290 L 320,346 L 200,346 Z" fill="#444"/>
                <rect id="tank3-section2" x="200" y="346" width="120" height="66" fill="#444"/>
                <path id="tank3-section3" d="M 200,412 L 320,412 L 320,470 Q 320,480 310,480 L 210,480 Q 200,480 200,470 Z" fill="#444"/>
                <text id="tank3-depth1" x="260" y="320" text-anchor="middle" fill="white" font-family="Montserrat, sans-serif" font-size="12" font-weight="600">-</text>
                <text id="tank3-depth2" x="260" y="386" text-anchor="middle" fill="white" font-family="Montserrat, sans-serif" font-size="12" font-weight="600">-</text>
                <text id="tank3-depth3" x="260" y="452" text-anchor="middle" fill="white" font-family="Montserrat, sans-serif" font-size="12" font-weight="600">-</text>
                <text x="260" y="500" text-anchor="middle" fill="var(--text-color)" font-family="Montserrat, sans-serif" font-size="14" font-weight="600">Tank 3</text>
                
                <!-- Tank 2 (bottom center) -->
                <rect x="330" y="280" width="120" height="200" rx="10" fill="transparent"/>
                <!-- Tank 2 sections -->
                <path id="tank2-section1" d="M 330,290 Q 330,280 340,280 L 440,280 Q 450,280 450,290 L 450,346 L 330,346 Z" fill="#444"/>
                <rect id="tank2-section2" x="330" y="346" width="120" height="66" fill="#444"/>
                <path id="tank2-section3" d="M 330,412 L 450,412 L 450,470 Q 450,480 440,480 L 340,480 Q 330,480 330,470 Z" fill="#444"/>
                <text id="tank2-depth1" x="390" y="320" text-anchor="middle" fill="white" font-family="Montserrat, sans-serif" font-size="12" font-weight="600">-</text>
                <text id="tank2-depth2" x="390" y="386" text-anchor="middle" fill="white" font-family="Montserrat, sans-serif" font-size="12" font-weight="600">-</text>
                <text id="tank2-depth3" x="390" y="452" text-anchor="middle" fill="white" font-family="Montserrat, sans-serif" font-size="12" font-weight="600">-</text>
                <text x="390" y="500" text-anchor="middle" fill="var(--text-color)" font-family="Montserrat, sans-serif" font-size="14" font-weight="600">Tank 2</text>
                
                <!-- Tank 1 (bottom right) -->
                <rect x="460" y="280" width="120" height="200" rx="10" fill="transparent"/>
                <!-- Tank 1 sections -->
                <path id="tank1-section1" d="M 460,290 Q 460,280 470,280 L 570,280 Q 580,280 580,290 L 580,346 L 460,346 Z" fill="#444"/>
                <rect id="tank1-section2" x="460" y="346" width="120" height="66" fill="#444"/>
                <path id="tank1-section3" d="M 460,412 L 580,412 L 580,470 Q 580,480 570,480 L 470,480 Q 460,480 460,470 Z" fill="#444"/>
                <text id="tank1-depth1" x="520" y="320" text-anchor="middle" fill="white" font-family="Montserrat, sans-serif" font-size="12" font-weight="600">-</text>
                <text id="tank1-depth2" x="520" y="386" text-anchor="middle" fill="white" font-family="Montserrat, sans-serif" font-size="12" font-weight="600">-</text>
                <text id="tank1-depth3" x="520" y="452" text-anchor="middle" fill="white" font-family="Montserrat, sans-serif" font-size="12" font-weight="600">-</text>
                <text x="520" y="500" text-anchor="middle" fill="var(--text-color)" font-family="Montserrat, sans-serif" font-size="14" font-weight="600">Tank 1</text>
                
                <!-- Top pipe (from top of heat pump to top of buffer) -->
                <rect id="hp-buffer-top-pipe" x="140" y="75" width="720" height="15" fill="#888"/>
                <text id="hp-lwt" x="170" y="70" text-anchor="middle" fill="var(--text-color)" font-family="Montserrat, sans-serif" font-size="12" font-weight="600">-</text>
                <text id="buffer-hot-pipe" x="830" y="70" text-anchor="middle" fill="var(--text-color)" font-family="Montserrat, sans-serif" font-size="12" font-weight="600">-</text>

                <!-- Bottom pipe (from bottom of heat pump to bottom of buffer) -->
                <rect id="hp-buffer-bottom-pipe" x="140" y="215" width="720" height="15" fill="#888"/>
                <text id="hp-ewt" x="170" y="210" text-anchor="middle" fill="var(--text-color)" font-family="Montserrat, sans-serif" font-size="12" font-weight="600">-</text>
                <text id="buffer-cold-pipe" x="830" y="210" text-anchor="middle" fill="var(--text-color)" font-family="Montserrat, sans-serif" font-size="12" font-weight="600">-</text>

                <!-- Horizontal pipe from Tank1 vertical pipe to heat pump top (HpOnStoreCharge) -->
                <rect id="tank1-hp-horizontal-pipe-charge" x="140" y="75" width="465" height="15" fill="#888"/>
                
                <!-- Horizontal pipe from Tank3 vertical pipe to heat pump bottom (HpOnStoreCharge) -->
                <rect id="tank3-hp-horizontal-pipe-charge" x="140" y="215" width="50" height="15" fill="#888"/>

                <!-- Vertical pipe from Tank 1 to heat pump top pipe (HpOffStoreDischarge) -->
                <rect id="tank1-hp-vertical-pipe" x="590" y="90" width="15" height="205" fill="#888"/>
                
                <!-- Horizontal pipe from Tank1-HP vertical pipe to buffer top (HpOffStoreDischarge) -->
                <rect id="tank1-buffer-horizontal-pipe" x="590" y="75" width="270" height="15" fill="#888"/>
                
                <!-- Small horizontal pipe from bottom of vertical pipe to top of Tank1 (HpOffStoreDischarge) -->
                <rect id="tank1-connection-pipe" x="580" y="295" width="25" height="15" fill="#888"/>
                
                <!-- Vertical pipe from bottom left of Tank3 to HP-Buffer bottom pipe (HpOffStoreDischarge) -->
                <rect id="tank3-hp-vertical-pipe" x="175" y="220" width="15" height="220" fill="#888"/>
                
                <!-- Horizontal pipe from top of Tank3 vertical pipe to bottom of buffer (HpOffStoreDischarge) -->
                <rect id="tank3-buffer-horizontal-pipe" x="175" y="215" width="685" height="15" fill="#888"/>
                
                <!-- Small horizontal pipe from Tank3 vertical pipe to bottom of Tank3 (HpOffStoreDischarge) -->
                <rect id="tank3-connection-pipe" x="175" y="440" width="25" height="15" fill="#888"/>
                
                <!-- Vertical pipe from Tank1 to heat pump top pipe (HpOnStoreCharge) -->
                <rect id="tank1-hp-vertical-pipe-charge" x="590" y="90" width="15" height="205" fill="#888"/>
                
                <!-- Vertical pipe from bottom left of Tank3 to HP-Buffer bottom pipe (HpOnStoreCharge) -->
                <rect id="tank3-hp-vertical-pipe-charge" x="175" y="220" width="15" height="220" fill="#888"/>
                
                <!-- Small horizontal pipe from Tank1 vertical pipe to top of Tank1 (HpOnStoreCharge) -->
                <rect id="tank1-connection-pipe-charge" x="580" y="295" width="25" height="15" fill="#888"/>
                
                <!-- Small horizontal pipe from Tank3 vertical pipe to bottom of Tank3 (HpOnStoreCharge) -->
                <rect id="tank3-connection-pipe-charge" x="175" y="440" width="25" height="15" fill="#888"/>
                
            </svg>
        </div>

        <h1 style="text-align: center; margin-top: 30px; margin-bottom: 20px;">Admin panel</h1>
    
        <div id="control-panel" style="text-align: center; max-width: 770px; margin: 0px auto 20px auto; background-color: transparent; border: 0px solid #ddd; border-radius: 3px; padding: 20px;">
            <div style="display: flex; align-items: center; justify-content: center; gap: 20px; flex-wrap: wrap;">
                <div id="timer-display" style="font-family: monospace; font-size: 25px; color: #333; font-weight: bold; margin-right: 20px;">00:00:00</div>
                <div style="display: inline-block;">
                    <label for="timeout-input">Timeout (minutes):</label>
                    <input type="number" id="timeout-input" value="5" min="1" max="1440" style="width: 60px; margin: 0 5px; padding: 8px 14px; border: 1px solid var(--border-color); border-radius: 0.25rem; background-color: white; font-family: inherit; font-size: inherit;">
                </div>
                <button id="keep-alive-btn" onclick="sendKeepAlive()" style="margin: 0 5px; padding: 8px 14px; border: 1px solid var(--border-color); border-radius: 0.25rem; background-color: #FAFAFA; cursor: pointer; font-family: inherit; font-size: inherit;">Keep alive</button>
                <button id="release-control-btn" onclick="sendReleaseControl()" style="margin: 0 5px; padding: 8px 14px; border: 1px solid var(--border-color); border-radius: 0.25rem; background-color: #FAFAFA; cursor: pointer; font-family: inherit; font-size: inherit;">Release control</button>
            </div>
        </div>
        
        <div id="relays" style="margin-bottom: 40px;"></div>

    <style>
        :root {
            /* Dark mode colors (default) */
            --background-color: #f8f9fa;
            --card-background: #ffffff;
            --datetime-background: #f1f3f5;
            --datetime-text: #1b1b1c;
            --text-color: #212529;
            --text-muted: #6c757d;
            --border-color: rgba(0, 0, 0, 0.1);
            --hover-color: #f1f3f5;
        }

        body {
            font-family: 'Montserrat', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            color: var(--text-color);
            background-color: var(--background-color);
            font-size: 14px;
            margin: 0;
            padding: 0;
        }

        table tr:hover {
            background-color: var(--hover-color);
        }
    </style>


    <script>
        let websocket = null;
        let relays = {};
        let thermostatNames = [];
        let currentUserId = 'user_' + Math.random().toString(36).substr(2, 9);

        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//visualizer.electricity.works:8080/ws`;
            
            websocket = new WebSocket(wsUrl);
            
            websocket.onopen = function(event) {
                document.getElementById('status-left').textContent = 'Connected';
                document.getElementById('status-right').textContent = '';
                console.log('WebSocket connected');
            };
            
            websocket.onmessage = function(event) {
                const data = JSON.parse(event.data);
                handleMessage(data);
            };
            
            websocket.onclose = function(event) {
                document.getElementById('status-left').textContent = 'Disconnected';
                document.getElementById('status-right').textContent = 'Please refresh the page';
                console.log('WebSocket disconnected');
                
                // Clear the relay table and show disconnected message
                const relaysDiv = document.getElementById('relays');
                relaysDiv.innerHTML = '';
                const controlPanel = document.getElementById('control-panel');
                controlPanel.innerHTML = '';
            };
            
            websocket.onerror = function(error) {
                console.error('WebSocket error:', error);
                document.getElementById('status-left').textContent = 'Error';
                document.getElementById('status-right').textContent = 'Connection failed';
            };
        }

        function handleMessage(data) {
            console.log('Received message:', data);
            
            if (data.type === 'status') {
                updateStatus(data);
            } else if (data.type === 'timer_update') {
                updateTimer(data);
            } else if (data.type === 'mqtt_message') {
                // Handle MQTT messages (could be relay state updates)
                if (data.message_type === 'single.reading') {
                    updateRelayState(data.payload);
                } else if (data.message_type === 'snapshot.spaceheat') {
                    updateMonitoringTables(data.payload);
                }
            } else if (data.type === 'error') {
                console.error('Error: ' + data.message);
            }
        }

        function updateStatus(data) {
            // Build status for left and right sides
            let leftStatus = '';
            let rightStatus = '';
            
            // Left side: target_gnode (bold)
            const gnodeParts = data.target_gnode ? data.target_gnode.split('.') : [];
            const beforeLastPart = gnodeParts.length > 1 ? gnodeParts[gnodeParts.length - 2] : '';
            const capitalizedPart = beforeLastPart.charAt(0).toUpperCase() + beforeLastPart.slice(1);
            if (data.target_gnode) {
                leftStatus = `<b style="font-size: 1.5em;">${capitalizedPart}</b>`;
            }
            
            // Right side: full gnode
            if (data.target_gnode) {
                rightStatus = `<span style="color: var(--text-muted); font-size: 1em;">${data.target_gnode}</span>`;
            }

            
            // Second line: MQTT connection status and message count
            // if (data.mqtt_connected) {
            //     statusText += 'MQTT broker connection: active';
            // } else {
            //     statusText += 'MQTT broker connection: inactive';
            // }
            
            // if (data.messages_received !== undefined) {
            //     statusText += ` | Messages received: ${data.messages_received}`;
            // }
            
            document.getElementById('status-left').innerHTML = leftStatus;
            document.getElementById('status-right').innerHTML = rightStatus;
            
            // Update relays
            if (data.relays) {
                relays = data.relays;
                updateRelayButtons();
            }
            
            // Update thermostat names
            if (data.thermostat_names) {
                thermostatNames = data.thermostat_names;
                console.log('Updated thermostat names:', thermostatNames);
            }
            
            // Update timer from status
            if (data.time_remaining !== undefined) {
                updateTimer({ time_remaining: data.time_remaining, controller: data.controller });
            }
        }
        
        function updateTimer(data) {
            const hours = Math.floor(data.time_remaining / 3600);
            const minutes = Math.floor((data.time_remaining % 3600) / 60);
            const seconds = Math.floor(data.time_remaining % 60);
            
            const timerElement = document.getElementById('timer-display');
            timerElement.textContent = 
                `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // Change color based on timer state
            if (data.time_remaining > 0) {
                timerElement.style.color = '#CC1616';
            } else {
                timerElement.style.color = '#333';
            }
            
            // Show who has control
            // if (data.controller) {
            //     const isCurrentUser = data.controller === currentUserId;
            //     document.getElementById('control-status').textContent = 
            //         // `Control: ${data.controller}${isCurrentUser ? ' (You)' : ''}`;
            //         `Last action done by ${isCurrentUser ? ' you' : 'another user'}`;
            //     } else {
            //     document.getElementById('control-status').textContent = 'No control';
            // }
        }

        function updateRelayButtons() {
            const relaysDiv = document.getElementById('relays');
            relaysDiv.innerHTML = '';
            
            // Create table
            const table = document.createElement('table');
            table.style.border = '1px solid var(--border-color)';
            table.style.borderCollapse = 'collapse';
            table.style.borderRadius = '0.25rem';
            table.style.maxWidth = '1000px';
            table.style.margin = '0 auto'; // Center horizontally
            table.style.backgroundColor = 'var(--card-background)';
            
            // Create header row
            const headerRow = document.createElement('tr');
            const headers = ['Relay', 'Name', 'Current State', 'Action', 'Energized'];
            headers.forEach((headerText, index) => {
                const th = document.createElement('th');
                th.textContent = headerText;
                // th.style.border = '1px solid var(--border-color)';
                th.style.padding = '8px 10px';
                th.style.backgroundColor = '#f0f0f0';
                
                // Set fixed width for "Current State" column (index 2)
                if (index === 2) {
                    th.style.width = '170px';
                }
                
                headerRow.appendChild(th);
            });
            table.appendChild(headerRow);
            
            // Sort relays by relay number
            const sortedRelays = Object.entries(relays).sort((a, b) => {
                const relayNumberA = parseInt(a[0].replace('relay', ''));
                const relayNumberB = parseInt(b[0].replace('relay', ''));
                return relayNumberA - relayNumberB;
            });
            
            // Create data rows
            for (const [relayName, relayInfo] of sortedRelays) {
                const row = document.createElement('tr');
                
                // Extract relay number from relay name (e.g., "relay1" -> "1")
                const relayNumber = relayName.replace('relay', '');
                
                // Get current state
                const currentState = relayInfo.state || 'unknown';
                
                // Get the actual state description for this relay
                let currentStateDescription = 'unknown';
                if (currentState === 'energized') {
                    currentStateDescription = relayInfo.energized_state || 'energized';
                } else if (currentState === 'deenergized') {
                    currentStateDescription = relayInfo.deenergized_state || 'deenergized';
                }
                
                // Determine action text based on current state using actual event names
                let actionText = 'unknown';
                if (currentState === 'energized') {
                    actionText = relayInfo.de_energizing_event || 'De-energize';
                } else if (currentState === 'deenergized') {
                    actionText = relayInfo.energizing_event || 'Energize';
                }
                
                // Determine energized icon
                const energizedIcon = currentState === 'energized' ? 'ðŸ”´' : 'âšª';
                
                // Create cells
                const cells = [
                    relayNumber,
                    relayInfo.display_name.replace(/Relay\s*/i, ''),
                    currentStateDescription,
                    actionText,
                    energizedIcon
                ];
                
                cells.forEach((cellText, index) => {
                    const td = document.createElement('td');
                    // Only show left and right borders for data cells (no top/bottom borders between rows)
                    // td.style.borderLeft = '1px solid var(--border-color)';
                    // td.style.borderRight = '1px solid var(--border-color)';
                    td.style.padding = '2px 16px';
                    
                    if (index === 3) { // Action column - make it clickable
                        const button = document.createElement('button');
                        button.textContent = cellText;
                        button.onclick = () => toggleRelay(relayName);
                        button.style.width = '200px';
                        button.style.padding = '3px 14px';
                        button.style.border = '1px solid var(--border-color)';
                        button.style.borderRadius = '0.25rem';
                        button.style.backgroundColor = currentState === 'energized' ? '#FAFAFA' : '#FAFAFA';
                        button.style.cursor = 'pointer';
                        button.style.fontFamily = 'inherit';
                        button.style.fontSize = 'inherit';
                        td.appendChild(button);
                    } else if (index === 4) { // Energized column - center the content
                        td.textContent = cellText;
                        td.style.textAlign = 'center';
                    } else {
                        td.textContent = cellText;
                    }
                    
                    row.appendChild(td);
                });
                
                table.appendChild(row);
            }
            
            // Add bottom border to the last row
            if (sortedRelays.length > 0) {
                const lastRow = table.rows[table.rows.length - 1];
                for (let i = 0; i < lastRow.cells.length; i++) {
                    lastRow.cells[i].style.borderBottom = '1px solid var(--border-color)';
                }
            }
            
            relaysDiv.appendChild(table);
            
            // Update system state after updating relay buttons
            updateSystemState();
        }

        function updateSystemState() {
            const hpStateElement = document.getElementById('hp-state');
            const storageStateElement = document.getElementById('storage-state');
            const combinedStateElement = document.getElementById('combined-state');
            
            // Check if we have relay 5 and relay 6 data for HP state
            const relay5 = relays['relay5'];
            const relay6 = relays['relay6'];
            
            let hpState = '';
            let hpStateColor = 'var(--text-color)';
            let hpOn = false;
            
            if (!relay5 || !relay6) {
                hpStateElement.textContent = 'Waiting for relay data...';
                hpStateElement.style.color = 'var(--text-muted)';
            } else {
                const relay5State = relay5.state;
                const relay6State = relay6.state;
                
                if (relay5State === 'energized' && relay6State === 'deenergized') {
                    hpState = 'HP on';
                    hpStateColor = '#28a745'; // Green for "on"
                    hpOn = true;
                } else if (relay5State === 'energized' && relay6State === 'energized') {
                    hpState = 'HP off';
                    hpStateColor = '#dc3545'; // Red for "off"
                    hpOn = false;
                } else if (relay5State === 'deenergized') {
                    hpState = 'HP in tank aquastat';
                    hpStateColor = '#ffc107'; // Yellow for "aquastat"
                    hpOn = false;
                } else {
                    hpState = 'Unknown state';
                    hpStateColor = 'var(--text-muted)';
                }
                
                hpStateElement.textContent = hpState;
                hpStateElement.style.color = hpStateColor;
            }
            
            // Check if we have relay 3 and relay 9 data for storage state
            const relay3 = relays['relay3'];
            const relay9 = relays['relay9'];
            
            let storageState = '';
            let storageStateColor = 'var(--text-color)';
            let storeCharge = false;
            let storeDischarge = false;
            
            if (!relay3 || !relay9) {
                storageStateElement.textContent = 'Waiting for relay data...';
                storageStateElement.style.color = 'var(--text-muted)';
            } else {
                const relay3State = relay3.state;
                const relay9State = relay9.state;
                
                if (relay3State === 'energized') {
                    storageState = 'Store Charge';
                    storageStateColor = '#17a2b8'; // Blue for "charging"
                    storeCharge = true;
                } else if (relay3State === 'deenergized' && relay9State === 'energized') {
                    storageState = 'Store Discharging';
                    storageStateColor = '#fd7e14'; // Orange for "discharging"
                    storeDischarge = true;
                } else if (relay3State === 'deenergized' && relay9State === 'deenergized') {
                    storageState = 'Store idle';
                    storageStateColor = '#6c757d'; // Gray for "idle"
                } else {
                    storageState = 'Unknown state';
                    storageStateColor = 'var(--text-muted)';
                }
                
                storageStateElement.textContent = storageState;
                storageStateElement.style.color = storageStateColor;
            }
            
            // Calculate combined state
            let combinedState = '';
            let combinedStateColor = 'var(--text-color)';
            
            if (hpOn && storeCharge) {
                combinedState = 'HpOnStoreCharge';
                combinedStateColor = '#28a745'; // Green
            } else if (hpOn && !storeCharge && !storeDischarge) {
                combinedState = 'HpOnStoreOff';
                combinedStateColor = '#17a2b8'; // Blue
            } else if (!hpOn && storeDischarge) {
                combinedState = 'HpOffStoreDischarge';
                combinedStateColor = '#fd7e14'; // Orange
            } else if (!hpOn && !storeCharge && !storeDischarge) {
                combinedState = 'HpOffStoreOff';
                combinedStateColor = '#6c757d'; // Gray
            } else {
                combinedState = 'Unknown combined state';
                combinedStateColor = 'var(--text-muted)';
            }
            
            combinedStateElement.textContent = combinedState;
            combinedStateElement.style.color = combinedStateColor;

            hpStateElement.textContent = '';
            storageStateElement.textContent = '';
        }

        function updateRelayState(payload) {
            // Update individual relay state from MQTT message
            if (payload && payload.relay_name && payload.state) {
                relays[payload.relay_name] = {
                    ...relays[payload.relay_name],
                    state: payload.state
                };
                
                // Update the relay buttons display
                updateRelayButtons();
                
                // Update system state
                updateSystemState();
            }
        }

        function toggleRelay(relayName) {
            if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                console.error('Not connected to server');
                return;
            }

            const message = {
                type: 'relay_control',
                data: {
                    relay_name: relayName,
                    timeout_seconds: 300,
                    user_id: currentUserId
                }
            };
            
            websocket.send(JSON.stringify(message));
            console.log(`Toggling relay ${relayName}`);
        }



        function sendKeepAlive() {
            if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                console.error('Not connected to server');
                return;
            }

            const timeoutMinutes = parseInt(document.getElementById('timeout-input').value) || 5;
            const timeoutSeconds = timeoutMinutes * 60;

            const message = {
                type: 'keepalive',
                data: {
                    timeout_seconds: timeoutSeconds,
                    user_id: currentUserId
                }
            };

            websocket.send(JSON.stringify(message));
            console.log(`Sending keep alive for ${timeoutMinutes} minutes`);
        }

        function sendReleaseControl() {
            if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                console.error('Not connected to server');
                return;
            }

            const message = {
                type: 'release_control',
                data: {}
            };

            websocket.send(JSON.stringify(message));
            console.log('Sending release control');
        }

        function updateMonitoringTables(snapshotData) {
            console.log('Updating monitoring tables with snapshot data:', snapshotData);
            console.log('LatestReadingList:', snapshotData.LatestReadingList);
            console.log('LatestStateList:', snapshotData.LatestStateList);
            
            // Update thermostat table
            updateThermostatTable(snapshotData);
            
            // Update power and pump table
            updatePowerPumpTable(snapshotData);
            
            // Update tank temperatures
            updateTankTemperatures(snapshotData);
            
            // Store snapshot data for test mode dropdown
            window.lastSnapshotData = snapshotData;
            
            // Update pipe colors based on system state
            updatePipeColors(snapshotData);
        }

        function updateThermostatTable(snapshotData) {
            const tbody = document.getElementById('thermostat-tbody');
            if (!tbody || !snapshotData.LatestReadingList) return;
            
            // Use dynamic thermostat names from the server
            if (!thermostatNames || thermostatNames.length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" style="border: 1px solid var(--border-color); padding: 8px; text-align: center;">Loading thermostat names...</td></tr>';
                return;
            }
            
            // Create zone mappings dynamically from thermostat names
            const zones = thermostatNames.map((name, index) => ({
                key: `zone${index + 1}-${name}`,
                display: `zone${index + 1}-${name}`
            }));
            
            // Create a lookup map for readings
            const readingsMap = {};
            snapshotData.LatestReadingList.forEach(reading => {
                readingsMap[reading.ChannelName] = reading;
            });
            
            // Debug: Log all available readings
            console.log('Available readings for thermostat table:', Object.keys(readingsMap));
            console.log('Using thermostat zones:', zones);
            
            tbody.innerHTML = '';
            
            zones.forEach(zone => {
                // Look for temperature and set point readings for this zone using actual channel names
                const tempReading = readingsMap[`${zone.key}-temp`];
                const setPointReading = readingsMap[`${zone.key}-set`];
                const stateReading = readingsMap[`${zone.key}-state`];
                
                // Temperature values are in degrees Fahrenheit * 10
                const tempF = tempReading ? (tempReading.Value / 1000).toFixed(1) : '-';
                const setPointF = setPointReading ? (setPointReading.Value / 1000).toFixed(1) : '-';
                const state = stateReading ? (stateReading.Value > 0 ? 'heating' : 'idle') : 'idle';
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td style="border: 1px solid var(--border-color); padding: 8px;">${zone.display}</td>
                    <td style="border: 1px solid var(--border-color); padding: 8px;">${setPointF}Â°F</td>
                    <td style="border: 1px solid var(--border-color); padding: 8px;">${tempF}Â°F</td>
                    <td style="border: 1px solid var(--border-color); padding: 8px;">${state}</td>
                `;
                tbody.appendChild(row);
            });
        }

        function updatePowerPumpTable(snapshotData) {
            if (!snapshotData.LatestReadingList) return;
            
            // Create a lookup map for readings
            const readingsMap = {};
            snapshotData.LatestReadingList.forEach(reading => {
                readingsMap[reading.ChannelName] = reading;
            });
            
            // Debug: Log all available readings
            console.log('Available readings for power/pump table:', Object.keys(readingsMap));
            
            // Update HP Power table
            updateHpPowerTable(readingsMap);
            
            // Update Pump table
            updatePumpTable(readingsMap);
        }

        function updateHpPowerTable(readingsMap) {
            const tbody = document.getElementById('hp-power-tbody');
            if (!tbody) return;
            
            // Get power readings using actual channel names
            const hpOduReading = readingsMap['hp-odu-pwr'];
            const hpIduReading = readingsMap['hp-idu-pwr'];
            const hpTotalReading = hpOduReading && hpIduReading ? 
                { Value: hpOduReading.Value + hpIduReading.Value } : null;
            
            // Convert power from watts to kW
            const hpTotalKw = hpTotalReading ? (hpTotalReading.Value / 1000).toFixed(2) : '0.00';
            const hpOduKw = hpOduReading ? (hpOduReading.Value / 1000).toFixed(2) : '0.00';
            const hpIduKw = hpIduReading ? (hpIduReading.Value / 1000).toFixed(2) : '0.00';
            
            tbody.innerHTML = '';
            
            // Outdoor row
            const row2 = document.createElement('tr');
            row2.innerHTML = `
                <td style="border: 1px solid var(--border-color); padding: 8px;">Outdoor unit</td>
                <td style="border: 1px solid var(--border-color); padding: 8px;">${hpOduKw}</td>
            `;
            tbody.appendChild(row2);
            
            // Indoor row
            const row3 = document.createElement('tr');
            row3.innerHTML = `
                <td style="border: 1px solid var(--border-color); padding: 8px;">Indoor unit</td>
                <td style="border: 1px solid var(--border-color); padding: 8px;">${hpIduKw}</td>
            `;
            tbody.appendChild(row3);

            // HP Total row
            const row1 = document.createElement('tr');
            row1.innerHTML = `
                <td style="border: 1px solid var(--border-color); padding: 8px;">Total</td>
                <td style="border: 1px solid var(--border-color); padding: 8px;">${hpTotalKw}</td>
            `;
            tbody.appendChild(row1);
        }

        function updatePumpTable(readingsMap) {
            const tbody = document.getElementById('pump-tbody');
            if (!tbody) return;
            
            // Get pump readings using actual channel names
            const primaryFlowReading = readingsMap['primary-flow'];
            const primaryPowerReading = readingsMap['primary-pump-pwr'];
            const distFlowReading = readingsMap['dist-flow'];
            const distPowerReading = readingsMap['dist-pump-pwr'];
            const storeFlowReading = readingsMap['store-flow'];
            const storePowerReading = readingsMap['store-pump-pwr'];
            
            tbody.innerHTML = '';
            
            // Primary pump row
            const row1 = document.createElement('tr');
            row1.innerHTML = `
                <td style="border: 1px solid var(--border-color); padding: 8px;">Primary</td>
                <td style="border: 1px solid var(--border-color); padding: 8px;">${primaryFlowReading ? (primaryFlowReading.Value / 100).toFixed(1) : '0.0'}</td>
                <td style="border: 1px solid var(--border-color); padding: 8px;">${primaryPowerReading && primaryPowerReading.Value > 0 ? primaryPowerReading.Value.toFixed(1) : '0.0'}</td>
            `;
            tbody.appendChild(row1);
            
            // Distribution pump row
            const row2 = document.createElement('tr');
            row2.innerHTML = `
                <td style="border: 1px solid var(--border-color); padding: 8px;">Distribution</td>
                <td style="border: 1px solid var(--border-color); padding: 8px;">${distFlowReading ? (distFlowReading.Value / 100).toFixed(1) : '0.0'}</td>
                <td style="border: 1px solid var(--border-color); padding: 8px;">${distPowerReading && distPowerReading.Value > 0 ? distPowerReading.Value.toFixed(1) : '0.0'}</td>
            `;
            tbody.appendChild(row2);
            
            // Storage pump row
            const row3 = document.createElement('tr');
            row3.innerHTML = `
                <td style="border: 1px solid var(--border-color); padding: 8px;">Store</td>
                <td style="border: 1px solid var(--border-color); padding: 8px;">${storeFlowReading ? (storeFlowReading.Value / 100).toFixed(1) : '0.0'}</td>
                <td style="border: 1px solid var(--border-color); padding: 8px;">${storePowerReading && storePowerReading.Value > 0 ? storePowerReading.Value.toFixed(1) : '0.0'}</td>
            `;
            tbody.appendChild(row3);
        }

        function updateLayerBackground(temp) {
            const minTemp = 50;
            const maxTemp = 160;
            const normalizedTemp = (temp - minTemp) / (maxTemp - minTemp);
            const red = Math.min(255, Math.floor(255 * normalizedTemp));
            const blue = Math.min(255, Math.floor(255 * (1 - normalizedTemp)));
            const backgroundColor = `rgba(${red}, 0, ${blue}, 0.86)`;
            return backgroundColor;
        }

        function updateTankTemperatures(snapshotData) {
            if (!snapshotData || !snapshotData.LatestReadingList) return;
            
            // Create a lookup map for readings
            const readingsMap = {};
            snapshotData.LatestReadingList.forEach(reading => {
                readingsMap[reading.ChannelName] = reading;
            });
            
            // Debug: Log all available readings
            console.log('Available readings for tank temperatures:', Object.keys(readingsMap));
            
            // Detect number of depth layers for each component
            const getMaxDepth = (componentName) => {
                let maxDepth = 3; // Default to 3 layers
                for (let depth = 4; depth <= 10; depth++) { // Check up to 10 layers
                    if (readingsMap[`${componentName}-depth${depth}`]) {
                        maxDepth = depth;
                    }
                }
                return maxDepth;
            };
            
            // Update each tank's temperature readings
            for (let tankNum = 1; tankNum <= 3; tankNum++) {
                const maxDepth = getMaxDepth(`tank${tankNum}`);
                console.log(`Tank ${tankNum} has ${maxDepth} depth layers`);
                
                // Create or update sections dynamically
                createTankSections(tankNum, maxDepth);
                
                for (let depth = 1; depth <= maxDepth; depth++) {
                    const channelName = `tank${tankNum}-depth${depth}`;
                    const reading = readingsMap[channelName];
                    const elementId = `tank${tankNum}-depth${depth}`;
                    const element = document.getElementById(elementId);
                    
                    if (element && reading) {
                        // Convert temperature from Celsius * 1000 to Fahrenheit
                        // Formula: Â°F = (Â°C * 9/5) + 32
                        const tempC = reading.Value / 1000; // Convert from degCx1000 to degC
                        const tempF = (tempC * 9/5 + 32).toFixed(1); // Convert to Fahrenheit
                        element.textContent = `${tempF}Â°F`;
                        
                        // Update background color based on temperature
                        const sectionElement = document.getElementById(`tank${tankNum}-section${depth}`);
                        if (sectionElement) {
                            const tempFNum = parseFloat(tempF);
                            const backgroundColor = updateLayerBackground(tempFNum);
                            sectionElement.setAttribute('fill', backgroundColor);
                        }
                        
                        console.log(`Updated ${channelName}: ${tempC}Â°C â†’ ${tempF}Â°F`);
                    } else if (element) {
                        // If no reading available, show placeholder
                        element.textContent = '-';
                        console.log(`No reading available for ${channelName}`);
                    }
                }
            }
            
            // Update buffer temperature readings
            const bufferMaxDepth = getMaxDepth('buffer');
            console.log(`Buffer has ${bufferMaxDepth} depth layers`);
            
            // Create or update buffer sections dynamically
            createBufferSections(bufferMaxDepth);
            
            for (let depth = 1; depth <= bufferMaxDepth; depth++) {
                const channelName = `buffer-depth${depth}`;
                const reading = readingsMap[channelName];
                const elementId = `buffer-depth${depth}`;
                const element = document.getElementById(elementId);
                
                if (element && reading) {
                    // Convert temperature from Celsius * 1000 to Fahrenheit
                    // Formula: Â°F = (Â°C * 9/5) + 32
                    const tempC = reading.Value / 1000; // Convert from degCx1000 to degC
                    const tempF = (tempC * 9/5 + 32).toFixed(1); // Convert to Fahrenheit
                    element.textContent = `${tempF}Â°F`;
                    
                    // Update background color based on temperature
                    const sectionElement = document.getElementById(`buffer-section${depth}`);
                    if (sectionElement) {
                        const tempFNum = parseFloat(tempF);
                        const backgroundColor = updateLayerBackground(tempFNum);
                        sectionElement.setAttribute('fill', backgroundColor);
                    }
                    
                    console.log(`Updated ${channelName}: ${tempC}Â°C â†’ ${tempF}Â°F`);
                } else if (element) {
                    // If no reading available, show placeholder
                    element.textContent = '-';
                    console.log(`No reading available for ${channelName}`);
                }
            }
            
            // Update heat pump leaving water temperature (hp-lwt)
            const hpLwtReading = readingsMap['hp-lwt'];
            const hpLwtElement = document.getElementById('hp-lwt');
            let hpLwtTempF = null;
            
            if (hpLwtElement && hpLwtReading) {
                // Convert temperature from Celsius * 1000 to Fahrenheit
                // Formula: Â°F = (Â°C * 9/5) + 32
                const tempC = hpLwtReading.Value / 1000; // Convert from degCx1000 to degC
                hpLwtTempF = parseFloat((tempC * 9/5 + 32).toFixed(1)); // Convert to Fahrenheit
                hpLwtElement.textContent = `${hpLwtTempF}Â°F`;
                
                console.log(`Updated hp-lwt: ${tempC}Â°C â†’ ${hpLwtTempF}Â°F`);
            } else if (hpLwtElement) {
                // If no reading available, show placeholder
                hpLwtElement.textContent = '-';
                console.log(`No reading available for hp-lwt`);
            }
            
            // Update heat pump entering water temperature (hp-ewt)
            const hpEwtReading = readingsMap['hp-ewt'];
            const hpEwtElement = document.getElementById('hp-ewt');
            let hpEwtTempF = null;
            
            if (hpEwtElement && hpEwtReading) {
                // Convert temperature from Celsius * 1000 to Fahrenheit
                // Formula: Â°F = (Â°C * 9/5) + 32
                const tempC = hpEwtReading.Value / 1000; // Convert from degCx1000 to degC
                hpEwtTempF = parseFloat((tempC * 9/5 + 32).toFixed(1)); // Convert to Fahrenheit
                hpEwtElement.textContent = `${hpEwtTempF}Â°F`;
                
                console.log(`Updated hp-ewt: ${tempC}Â°C â†’ ${hpEwtTempF}Â°F`);
            } else if (hpEwtElement) {
                // If no reading available, show placeholder
                hpEwtElement.textContent = '-';
                console.log(`No reading available for hp-ewt`);
            }
            
            // Calculate and update heat pump lift (hp-lwt - hp-ewt)
            const hpLiftElement = document.getElementById('hp-lift');
            if (hpLiftElement && hpLwtTempF !== null && hpEwtTempF !== null) {
                const lift = (hpLwtTempF - hpEwtTempF).toFixed(1);
                hpLiftElement.textContent = `Lift: ${lift}Â°F`;
                console.log(`Updated hp-lift: ${hpLwtTempF}Â°F - ${hpEwtTempF}Â°F = ${lift}Â°F`);
            } else if (hpLiftElement) {
                // If either temperature is not available, show placeholder
                hpLiftElement.textContent = 'Lift: -Â°F';
                console.log(`Cannot calculate lift - missing temperature data`);
            }
            
            // Update buffer hot pipe temperature (buffer-hot-pipe)
            const bufferHotPipeReading = readingsMap['buffer-hot-pipe'];
            const bufferHotPipeElement = document.getElementById('buffer-hot-pipe');
            
            if (bufferHotPipeElement && bufferHotPipeReading) {
                // Convert temperature from Celsius * 1000 to Fahrenheit
                // Formula: Â°F = (Â°C * 9/5) + 32
                const tempC = bufferHotPipeReading.Value / 1000; // Convert from degCx1000 to degC
                const tempF = (tempC * 9/5 + 32).toFixed(1); // Convert to Fahrenheit
                bufferHotPipeElement.textContent = `${tempF}Â°F`;
                
                console.log(`Updated buffer-hot-pipe: ${tempC}Â°C â†’ ${tempF}Â°F`);
            } else if (bufferHotPipeElement) {
                // If no reading available, show placeholder
                bufferHotPipeElement.textContent = '-';
                console.log(`No reading available for buffer-hot-pipe`);
            }
            
            // Update buffer cold pipe temperature (buffer-cold-pipe)
            const bufferColdPipeReading = readingsMap['buffer-cold-pipe'];
            const bufferColdPipeElement = document.getElementById('buffer-cold-pipe');
            
            if (bufferColdPipeElement && bufferColdPipeReading) {
                // Convert temperature from Celsius * 1000 to Fahrenheit
                // Formula: Â°F = (Â°C * 9/5) + 32
                const tempC = bufferColdPipeReading.Value / 1000; // Convert from degCx1000 to degC
                const tempF = (tempC * 9/5 + 32).toFixed(1); // Convert to Fahrenheit
                bufferColdPipeElement.textContent = `${tempF}Â°F`;
                
                console.log(`Updated buffer-cold-pipe: ${tempC}Â°C â†’ ${tempF}Â°F`);
            } else if (bufferColdPipeElement) {
                // If no reading available, show placeholder
                bufferColdPipeElement.textContent = '-';
                console.log(`No reading available for buffer-cold-pipe`);
            }
            
            // Update house distribution supply water temperature (dist-swt)
            const distSwtReading = readingsMap['dist-swt'];
            let distSwtTempF = null;
            
            if (distSwtReading) {
                // Convert temperature from Celsius * 1000 to Fahrenheit
                // Formula: Â°F = (Â°C * 9/5) + 32
                const tempC = distSwtReading.Value / 1000; // Convert from degCx1000 to degC
                distSwtTempF = parseFloat((tempC * 9/5 + 32).toFixed(1)); // Convert to Fahrenheit
                console.log(`Updated dist-swt: ${tempC}Â°C â†’ ${distSwtTempF}Â°F`);
            } else {
                console.log(`No reading available for dist-swt`);
            }
            
            // Update house distribution return water temperature (dist-rwt)
            const distRwtReading = readingsMap['dist-rwt'];
            let distRwtTempF = null;
            
            if (distRwtReading) {
                // Convert temperature from Celsius * 1000 to Fahrenheit
                // Formula: Â°F = (Â°C * 9/5) + 32
                const tempC = distRwtReading.Value / 1000; // Convert from degCx1000 to degC
                distRwtTempF = parseFloat((tempC * 9/5 + 32).toFixed(1)); // Convert to Fahrenheit
                console.log(`Updated dist-rwt: ${tempC}Â°C â†’ ${distRwtTempF}Â°F`);
            } else {
                console.log(`No reading available for dist-rwt`);
            }
            
            // Calculate and update house drop (dist-swt - dist-rwt)
            const houseDropElement = document.getElementById('house-drop');
            if (houseDropElement && distSwtTempF !== null && distRwtTempF !== null) {
                const drop = (distSwtTempF - distRwtTempF).toFixed(1);
                houseDropElement.textContent = `Drop: ${drop}Â°F`;
                console.log(`Updated house-drop: ${distSwtTempF}Â°F - ${distRwtTempF}Â°F = ${drop}Â°F`);
            } else if (houseDropElement) {
                // If either temperature is not available, show placeholder
                houseDropElement.textContent = 'Drop: -Â°F';
                console.log(`Cannot calculate drop - missing temperature data`);
            }
        }

        function updatePipeColors(snapshotData) {
            console.log('=== updatePipeColors called ===');
            // Check if test mode is selected
            const testModeSelect = document.getElementById('testModeSelect');
            let currentState = null;
            
            if (testModeSelect && testModeSelect.value !== 'Auto') {
                // Use test mode selection - don't let WebSocket data override it
                currentState = testModeSelect.value;
                console.log('Using test mode (ignoring WebSocket data):', currentState);
            } else {
                // Get the current system state using the same logic as updateSystemState
                console.log('Using real system state from WebSocket data');
                
                // Check relay states to determine system state (same logic as updateSystemState)
                const relay5 = relays['relay5'];
                const relay6 = relays['relay6'];
                const relay3 = relays['relay3'];
                const relay9 = relays['relay9'];
                
                if (relay5 && relay6 && relay3 && relay9) {
                    const relay5State = relay5.state;
                    const relay6State = relay6.state;
                    const relay3State = relay3.state;
                    const relay9State = relay9.state;
                    
                    // Determine HP state
                    let hpOn = false;
                    if (relay5State === 'energized' && relay6State === 'deenergized') {
                        hpOn = true;
                    }
                    
                    // Determine storage state
                    let storeCharge = false;
                    let storeDischarge = false;
                    if (relay3State === 'energized') {
                        storeCharge = true;
                    } else if (relay3State === 'deenergized' && relay9State === 'energized') {
                        storeDischarge = true;
                    }
                    
                    // Calculate combined state
                    if (hpOn && storeCharge) {
                        currentState = 'HpOnStoreCharge';
                    } else if (hpOn && !storeCharge && !storeDischarge) {
                        currentState = 'HpOnStoreOff';
                    } else if (!hpOn && storeDischarge) {
                        currentState = 'HpOffStoreDischarge';
                    } else if (!hpOn && !storeCharge && !storeDischarge) {
                        currentState = 'HpOffStoreOff';
                    } else {
                        currentState = 'Unknown combined state';
                    }
                }
                
                console.log('Current system state (from relays):', currentState);
            }
            
            // Get pipe elements
            const hpBufferTopPipe = document.getElementById('hp-buffer-top-pipe');
            const hpBufferBottomPipe = document.getElementById('hp-buffer-bottom-pipe');
            const tank1HpVerticalPipe = document.getElementById('tank1-hp-vertical-pipe');
            const tank1BufferHorizontalPipe = document.getElementById('tank1-buffer-horizontal-pipe');
            const tank1ConnectionPipe = document.getElementById('tank1-connection-pipe');
            const tank3HpVerticalPipe = document.getElementById('tank3-hp-vertical-pipe');
            const tank3BufferHorizontalPipe = document.getElementById('tank3-buffer-horizontal-pipe');
            const tank3ConnectionPipe = document.getElementById('tank3-connection-pipe');
            const tank1HpVerticalPipeCharge = document.getElementById('tank1-hp-vertical-pipe-charge');
            const tank3HpVerticalPipeCharge = document.getElementById('tank3-hp-vertical-pipe-charge');
            const tank1ConnectionPipeCharge = document.getElementById('tank1-connection-pipe-charge');
            const tank3ConnectionPipeCharge = document.getElementById('tank3-connection-pipe-charge');
            const tank1HpHorizontalPipeCharge = document.getElementById('tank1-hp-horizontal-pipe-charge');
            const tank3HpHorizontalPipeCharge = document.getElementById('tank3-hp-horizontal-pipe-charge');
            
            // Set pipe colors based on state
            console.log(`Setting pipe colors for state: "${currentState}"`);
            
            if (currentState === 'HpOnStoreOff') {
                // Animated green pipes for HpOnStoreOff state (HP to Buffer)
                if (hpBufferTopPipe) {
                    hpBufferTopPipe.setAttribute('fill', 'url(#flowPattern)'); // Rightward flow
                    hpBufferTopPipe.removeAttribute('stroke');
                    // Move to end of SVG to appear on top
                    hpBufferTopPipe.parentNode.appendChild(hpBufferTopPipe);
                }
                if (hpBufferBottomPipe) {
                    hpBufferBottomPipe.setAttribute('fill', 'url(#leftFlowPattern)'); // Leftward flow
                    hpBufferBottomPipe.removeAttribute('stroke');
                    // Move to end of SVG to appear on top
                    hpBufferBottomPipe.parentNode.appendChild(hpBufferBottomPipe);
                }
                // Gray for Tank1 pipes
                if (tank1HpVerticalPipe) {
                    tank1HpVerticalPipe.setAttribute('fill', '#888');
                    tank1HpVerticalPipe.removeAttribute('stroke');
                }
                if (tank1BufferHorizontalPipe) {
                    tank1BufferHorizontalPipe.setAttribute('fill', '#888');
                    tank1BufferHorizontalPipe.removeAttribute('stroke');
                }
                if (tank1ConnectionPipe) {
                    tank1ConnectionPipe.setAttribute('fill', '#888');
                    tank1ConnectionPipe.removeAttribute('stroke');
                }
                if (tank3HpVerticalPipe) {
                    tank3HpVerticalPipe.setAttribute('fill', '#888');
                    tank3HpVerticalPipe.removeAttribute('stroke');
                }
                if (tank3BufferHorizontalPipe) {
                    tank3BufferHorizontalPipe.setAttribute('fill', '#888');
                    tank3BufferHorizontalPipe.removeAttribute('stroke');
                }
                if (tank3ConnectionPipe) {
                    tank3ConnectionPipe.setAttribute('fill', '#888');
                    tank3ConnectionPipe.removeAttribute('stroke');
                }
                if (tank1HpVerticalPipeCharge) {
                    tank1HpVerticalPipeCharge.setAttribute('fill', '#888');
                    tank1HpVerticalPipeCharge.removeAttribute('stroke');
                }
                if (tank3HpVerticalPipeCharge) {
                    tank3HpVerticalPipeCharge.setAttribute('fill', '#888');
                    tank3HpVerticalPipeCharge.removeAttribute('stroke');
                }
                if (tank1ConnectionPipeCharge) {
                    tank1ConnectionPipeCharge.setAttribute('fill', '#888');
                    tank1ConnectionPipeCharge.removeAttribute('stroke');
                }
                if (tank3ConnectionPipeCharge) {
                    tank3ConnectionPipeCharge.setAttribute('fill', '#888');
                    tank3ConnectionPipeCharge.removeAttribute('stroke');
                }
                if (tank1HpHorizontalPipeCharge) {
                    tank1HpHorizontalPipeCharge.setAttribute('fill', '#888');
                    tank1HpHorizontalPipeCharge.removeAttribute('stroke');
                }
                if (tank3HpHorizontalPipeCharge) {
                    tank3HpHorizontalPipeCharge.setAttribute('fill', '#888');
                    tank3HpHorizontalPipeCharge.removeAttribute('stroke');
                }
                console.log('Set HP-Buffer pipes to green for HpOnStoreOff state');
            } else if (currentState === 'HpOffStoreDischarge') {
                // Green pipes for HpOffStoreDischarge state (Tank1 to Buffer)
                console.log('Setting Tank1 pipes to green for HpOffStoreDischarge state');
                if (tank1HpVerticalPipe) {
                    tank1HpVerticalPipe.setAttribute('fill', 'url(#verticalFlowPattern)');
                    tank1HpVerticalPipe.removeAttribute('stroke');
                    tank1HpVerticalPipe.parentNode.appendChild(tank1HpVerticalPipe);
                    console.log('Successfully set Tank1-HP vertical pipe to animated green pattern');
                } else {
                    console.log('Tank1-HP vertical pipe element not found!');
                }
                if (tank1BufferHorizontalPipe) {
                    tank1BufferHorizontalPipe.setAttribute('fill', 'url(#flowPattern)');
                    tank1BufferHorizontalPipe.removeAttribute('stroke');
                    tank1BufferHorizontalPipe.parentNode.appendChild(tank1BufferHorizontalPipe);
                    console.log('Successfully set Tank1-Buffer horizontal pipe to animated green pattern');
                } else {
                    console.log('Tank1-Buffer horizontal pipe element not found!');
                }
                if (tank1ConnectionPipe) {
                    tank1ConnectionPipe.setAttribute('fill', 'url(#flowPattern)');
                    tank1ConnectionPipe.removeAttribute('stroke');
                    tank1ConnectionPipe.parentNode.appendChild(tank1ConnectionPipe);
                    console.log('Successfully set Tank1 connection pipe to animated green pattern');
                } else {
                    console.log('Tank1 connection pipe element not found!');
                }
                if (tank3HpVerticalPipe) {
                    tank3HpVerticalPipe.setAttribute('fill', 'url(#verticalDownFlowPattern)');
                    tank3HpVerticalPipe.removeAttribute('stroke');
                    tank3HpVerticalPipe.parentNode.appendChild(tank3HpVerticalPipe);
                    console.log('Successfully set Tank3-HP vertical pipe to animated green pattern');
                } else {
                    console.log('Tank3-HP vertical pipe element not found!');
                }
                if (tank3BufferHorizontalPipe) {
                    tank3BufferHorizontalPipe.setAttribute('fill', 'url(#leftFlowPattern)');
                    tank3BufferHorizontalPipe.removeAttribute('stroke');
                    tank3BufferHorizontalPipe.parentNode.appendChild(tank3BufferHorizontalPipe);
                    console.log('Successfully set Tank3-Buffer horizontal pipe to animated green pattern');
                } else {
                    console.log('Tank3-Buffer horizontal pipe element not found!');
                }
                if (tank3ConnectionPipe) {
                    tank3ConnectionPipe.setAttribute('fill', 'url(#flowPattern)');
                    tank3ConnectionPipe.removeAttribute('stroke');
                    tank3ConnectionPipe.parentNode.appendChild(tank3ConnectionPipe);
                    console.log('Successfully set Tank3 connection pipe to animated green pattern');
                } else {
                    console.log('Tank3 connection pipe element not found!');
                }
                // Gray for HpOnStoreCharge pipes
                if (tank1HpVerticalPipeCharge) {
                    tank1HpVerticalPipeCharge.setAttribute('fill', '#888');
                    tank1HpVerticalPipeCharge.removeAttribute('stroke');
                }
                if (tank3HpVerticalPipeCharge) {
                    tank3HpVerticalPipeCharge.setAttribute('fill', '#888');
                    tank3HpVerticalPipeCharge.removeAttribute('stroke');
                }
                if (tank1ConnectionPipeCharge) {
                    tank1ConnectionPipeCharge.setAttribute('fill', '#888');
                    tank1ConnectionPipeCharge.removeAttribute('stroke');
                }
                if (tank3ConnectionPipeCharge) {
                    tank3ConnectionPipeCharge.setAttribute('fill', '#888');
                    tank3ConnectionPipeCharge.removeAttribute('stroke');
                }
                // Gray for HP-Buffer pipes
                if (hpBufferTopPipe) {
                    hpBufferTopPipe.setAttribute('fill', '#888');
                    hpBufferTopPipe.removeAttribute('stroke');
                }
                if (hpBufferBottomPipe) {
                    hpBufferBottomPipe.setAttribute('fill', '#888');
                    hpBufferBottomPipe.removeAttribute('stroke');
                }
                if (tank1HpHorizontalPipeCharge) {
                    tank1HpHorizontalPipeCharge.setAttribute('fill', '#888');
                    tank1HpHorizontalPipeCharge.removeAttribute('stroke');
                }
                if (tank3HpHorizontalPipeCharge) {
                    tank3HpHorizontalPipeCharge.setAttribute('fill', '#888');
                    tank3HpHorizontalPipeCharge.removeAttribute('stroke');
                }
                console.log('Set Tank1 pipes to green for HpOffStoreDischarge state');
            } else if (currentState === 'HpOnStoreCharge') {
                // Green pipes for HpOnStoreCharge state (Tanks to HP)
                console.log('Setting HpOnStoreCharge pipes to green');
                if (tank1HpVerticalPipeCharge) {
                    tank1HpVerticalPipeCharge.setAttribute('fill', 'url(#verticalDownFlowPattern)'); // Downward flow
                    tank1HpVerticalPipeCharge.removeAttribute('stroke');
                    tank1HpVerticalPipeCharge.parentNode.appendChild(tank1HpVerticalPipeCharge);
                    console.log('Successfully set Tank1-HP vertical pipe (charge) to animated green');
                } else {
                    console.log('Tank1-HP vertical pipe (charge) element not found!');
                }
                if (tank3HpVerticalPipeCharge) {
                    tank3HpVerticalPipeCharge.setAttribute('fill', 'url(#verticalFlowPattern)'); // Upward flow
                    tank3HpVerticalPipeCharge.removeAttribute('stroke');
                    tank3HpVerticalPipeCharge.parentNode.appendChild(tank3HpVerticalPipeCharge);
                    console.log('Successfully set Tank3-HP vertical pipe (charge) to animated green');
                } else {
                    console.log('Tank3-HP vertical pipe (charge) element not found!');
                }
                if (tank1ConnectionPipeCharge) {
                    tank1ConnectionPipeCharge.setAttribute('fill', 'url(#leftFlowPattern)'); // Leftward flow
                    tank1ConnectionPipeCharge.removeAttribute('stroke');
                    tank1ConnectionPipeCharge.parentNode.appendChild(tank1ConnectionPipeCharge);
                    console.log('Successfully set Tank1 connection pipe (charge) to animated green');
                } else {
                    console.log('Tank1 connection pipe (charge) element not found!');
                }
                if (tank3ConnectionPipeCharge) {
                    tank3ConnectionPipeCharge.setAttribute('fill', 'url(#leftFlowPattern)'); // Leftward flow
                    tank3ConnectionPipeCharge.removeAttribute('stroke');
                    tank3ConnectionPipeCharge.parentNode.appendChild(tank3ConnectionPipeCharge);
                    console.log('Successfully set Tank3 connection pipe (charge) to animated green');
                } else {
                    console.log('Tank3 connection pipe (charge) element not found!');
                }
                if (tank1HpHorizontalPipeCharge) {
                    tank1HpHorizontalPipeCharge.setAttribute('fill', 'url(#flowPattern)'); // Rightward flow
                    tank1HpHorizontalPipeCharge.removeAttribute('stroke');
                    tank1HpHorizontalPipeCharge.parentNode.appendChild(tank1HpHorizontalPipeCharge);
                    console.log('Successfully set Tank1-HP horizontal pipe (charge) to animated green');
                } else {
                    console.log('Tank1-HP horizontal pipe (charge) element not found!');
                }
                if (tank3HpHorizontalPipeCharge) {
                    tank3HpHorizontalPipeCharge.setAttribute('fill', 'url(#leftFlowPattern)'); // Leftward flow
                    tank3HpHorizontalPipeCharge.removeAttribute('stroke');
                    tank3HpHorizontalPipeCharge.parentNode.appendChild(tank3HpHorizontalPipeCharge);
                    console.log('Successfully set Tank3-HP horizontal pipe (charge) to animated green');
                } else {
                    console.log('Tank3-HP horizontal pipe (charge) element not found!');
                }
                // Gray for all other pipes
                if (hpBufferTopPipe) {
                    hpBufferTopPipe.setAttribute('fill', '#888');
                    hpBufferTopPipe.removeAttribute('stroke');
                }
                if (hpBufferBottomPipe) {
                    hpBufferBottomPipe.setAttribute('fill', '#888');
                    hpBufferBottomPipe.removeAttribute('stroke');
                }
                if (tank1HpVerticalPipe) {
                    tank1HpVerticalPipe.setAttribute('fill', '#888');
                    tank1HpVerticalPipe.removeAttribute('stroke');
                }
                if (tank1BufferHorizontalPipe) {
                    tank1BufferHorizontalPipe.setAttribute('fill', '#888');
                    tank1BufferHorizontalPipe.removeAttribute('stroke');
                }
                if (tank1ConnectionPipe) {
                    tank1ConnectionPipe.setAttribute('fill', '#888');
                    tank1ConnectionPipe.removeAttribute('stroke');
                }
                if (tank3HpVerticalPipe) {
                    tank3HpVerticalPipe.setAttribute('fill', '#888');
                    tank3HpVerticalPipe.removeAttribute('stroke');
                }
                if (tank3BufferHorizontalPipe) {
                    tank3BufferHorizontalPipe.setAttribute('fill', '#888');
                    tank3BufferHorizontalPipe.removeAttribute('stroke');
                }
                if (tank3ConnectionPipe) {
                    tank3ConnectionPipe.setAttribute('fill', '#888');
                    tank3ConnectionPipe.removeAttribute('stroke');
                }
                console.log('Set HpOnStoreCharge pipes to green');
            } else {
                // Gray pipes for other states
                if (hpBufferTopPipe) {
                    hpBufferTopPipe.setAttribute('fill', '#888');
                    hpBufferTopPipe.removeAttribute('stroke');
                }
                if (hpBufferBottomPipe) {
                    hpBufferBottomPipe.setAttribute('fill', '#888');
                    hpBufferBottomPipe.removeAttribute('stroke');
                }
                if (tank1HpVerticalPipe) {
                    tank1HpVerticalPipe.setAttribute('fill', '#888');
                    tank1HpVerticalPipe.removeAttribute('stroke');
                }
                if (tank1BufferHorizontalPipe) {
                    tank1BufferHorizontalPipe.setAttribute('fill', '#888');
                    tank1BufferHorizontalPipe.removeAttribute('stroke');
                }
                if (tank1ConnectionPipe) {
                    tank1ConnectionPipe.setAttribute('fill', '#888');
                    tank1ConnectionPipe.removeAttribute('stroke');
                }
                if (tank3HpVerticalPipe) {
                    tank3HpVerticalPipe.setAttribute('fill', '#888');
                    tank3HpVerticalPipe.removeAttribute('stroke');
                }
                if (tank3BufferHorizontalPipe) {
                    tank3BufferHorizontalPipe.setAttribute('fill', '#888');
                    tank3BufferHorizontalPipe.removeAttribute('stroke');
                }
                if (tank3ConnectionPipe) {
                    tank3ConnectionPipe.setAttribute('fill', '#888');
                    tank3ConnectionPipe.removeAttribute('stroke');
                }
                if (tank1HpVerticalPipeCharge) {
                    tank1HpVerticalPipeCharge.setAttribute('fill', '#888');
                    tank1HpVerticalPipeCharge.removeAttribute('stroke');
                }
                if (tank3HpVerticalPipeCharge) {
                    tank3HpVerticalPipeCharge.setAttribute('fill', '#888');
                    tank3HpVerticalPipeCharge.removeAttribute('stroke');
                }
                if (tank1ConnectionPipeCharge) {
                    tank1ConnectionPipeCharge.setAttribute('fill', '#888');
                    tank1ConnectionPipeCharge.removeAttribute('stroke');
                }
                if (tank3ConnectionPipeCharge) {
                    tank3ConnectionPipeCharge.setAttribute('fill', '#888');
                    tank3ConnectionPipeCharge.removeAttribute('stroke');
                }
                if (tank1HpHorizontalPipeCharge) {
                    tank1HpHorizontalPipeCharge.setAttribute('fill', '#888');
                    tank1HpHorizontalPipeCharge.removeAttribute('stroke');
                }
                if (tank3HpHorizontalPipeCharge) {
                    tank3HpHorizontalPipeCharge.setAttribute('fill', '#888');
                    tank3HpHorizontalPipeCharge.removeAttribute('stroke');
                }
                console.log('Set all pipes to gray for state:', currentState);
            }
        }

        function createTankSections(tankNum, maxDepth) {
            // Tank positions
            const tankPositions = {
                1: { x: 460, y: 280 },
                2: { x: 330, y: 280 },
                3: { x: 200, y: 280 }
            };
            
            const pos = tankPositions[tankNum];
            if (!pos) return;
            
            const sectionHeight = 200 / maxDepth; // Divide total height by number of sections
            
            // Clear existing sections for this tank
            for (let i = 1; i <= 10; i++) {
                const existingSection = document.getElementById(`tank${tankNum}-section${i}`);
                const existingText = document.getElementById(`tank${tankNum}-depth${i}`);
                if (existingSection) existingSection.remove();
                if (existingText) existingText.remove();
            }
            
            // Create new sections
            for (let depth = 1; depth <= maxDepth; depth++) {
                const y = pos.y + (depth - 1) * sectionHeight;
                const height = sectionHeight;
                
                // Create section element
                let sectionElement;
                if (depth === 1) {
                    // Top section - rounded top corners only
                    sectionElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    const d = `M ${pos.x},${y + 10} Q ${pos.x},${y} ${pos.x + 10},${y} L ${pos.x + 110},${y} Q ${pos.x + 120},${y} ${pos.x + 120},${y + 10} L ${pos.x + 120},${y + height} L ${pos.x},${y + height} Z`;
                    sectionElement.setAttribute('d', d);
                } else if (depth === maxDepth) {
                    // Bottom section - rounded bottom corners only
                    sectionElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    const d = `M ${pos.x},${y} L ${pos.x + 120},${y} L ${pos.x + 120},${y + height - 10} Q ${pos.x + 120},${y + height} ${pos.x + 110},${y + height} L ${pos.x + 10},${y + height} Q ${pos.x},${y + height} ${pos.x},${y + height - 10} Z`;
                    sectionElement.setAttribute('d', d);
                } else {
                    // Middle section - no rounded corners
                    sectionElement = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    sectionElement.setAttribute('x', pos.x);
                    sectionElement.setAttribute('y', y);
                    sectionElement.setAttribute('width', 120);
                    sectionElement.setAttribute('height', height);
                }
                
                sectionElement.setAttribute('id', `tank${tankNum}-section${depth}`);
                sectionElement.setAttribute('fill', '#444');
                
                // Insert after the tank background rectangle
                const tankRect = document.querySelector(`rect[x="${pos.x}"][y="${pos.y}"]`);
                if (tankRect) {
                    tankRect.parentNode.insertBefore(sectionElement, tankRect.nextSibling);
                }
                
                // Create text element
                const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                textElement.setAttribute('id', `tank${tankNum}-depth${depth}`);
                textElement.setAttribute('x', pos.x + 60);
                textElement.setAttribute('y', y + height / 2 + 4);
                textElement.setAttribute('text-anchor', 'middle');
                textElement.setAttribute('fill', 'white');
                textElement.setAttribute('font-family', 'Montserrat, sans-serif');
                textElement.setAttribute('font-size', '12');
                textElement.setAttribute('font-weight', '600');
                textElement.textContent = '-';
                
                sectionElement.parentNode.insertBefore(textElement, sectionElement.nextSibling);
            }
        }

        function createBufferSections(maxDepth) {
            const pos = { x: 860, y: 50 };
            const sectionHeight = 200 / maxDepth; // Divide total height by number of sections
            
            // Clear existing sections for buffer
            for (let i = 1; i <= 10; i++) {
                const existingSection = document.getElementById(`buffer-section${i}`);
                const existingText = document.getElementById(`buffer-depth${i}`);
                if (existingSection) existingSection.remove();
                if (existingText) existingText.remove();
            }
            
            // Create new sections
            for (let depth = 1; depth <= maxDepth; depth++) {
                const y = pos.y + (depth - 1) * sectionHeight;
                const height = sectionHeight;
                
                // Create section element
                let sectionElement;
                if (depth === 1) {
                    // Top section - rounded top corners only
                    sectionElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    const d = `M ${pos.x},${y + 10} Q ${pos.x},${y} ${pos.x + 10},${y} L ${pos.x + 110},${y} Q ${pos.x + 120},${y} ${pos.x + 120},${y + 10} L ${pos.x + 120},${y + height} L ${pos.x},${y + height} Z`;
                    sectionElement.setAttribute('d', d);
                } else if (depth === maxDepth) {
                    // Bottom section - rounded bottom corners only
                    sectionElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    const d = `M ${pos.x},${y} L ${pos.x + 120},${y} L ${pos.x + 120},${y + height - 10} Q ${pos.x + 120},${y + height} ${pos.x + 110},${y + height} L ${pos.x + 10},${y + height} Q ${pos.x},${y + height} ${pos.x},${y + height - 10} Z`;
                    sectionElement.setAttribute('d', d);
                } else {
                    // Middle section - no rounded corners
                    sectionElement = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    sectionElement.setAttribute('x', pos.x);
                    sectionElement.setAttribute('y', y);
                    sectionElement.setAttribute('width', 120);
                    sectionElement.setAttribute('height', height);
                }
                
                sectionElement.setAttribute('id', `buffer-section${depth}`);
                sectionElement.setAttribute('fill', '#444');
                
                // Insert after the buffer background rectangle
                const bufferRect = document.querySelector(`rect[x="860"][y="50"]`);
                if (bufferRect) {
                    bufferRect.parentNode.insertBefore(sectionElement, bufferRect.nextSibling);
                }
                
                // Create text element
                const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                textElement.setAttribute('id', `buffer-depth${depth}`);
                textElement.setAttribute('x', pos.x + 60);
                textElement.setAttribute('y', y + height / 2 + 4);
                textElement.setAttribute('text-anchor', 'middle');
                textElement.setAttribute('fill', 'white');
                textElement.setAttribute('font-family', 'Montserrat, sans-serif');
                textElement.setAttribute('font-size', '12');
                textElement.setAttribute('font-weight', '600');
                textElement.textContent = '-';
                
                sectionElement.parentNode.insertBefore(textElement, sectionElement.nextSibling);
            }
        }

        // Initialize diagram with default 3 layers for each component
        function initializeDiagram() {
            // Initialize tanks with 3 layers each
            for (let tankNum = 1; tankNum <= 3; tankNum++) {
                createTankSections(tankNum, 3);
            }
            
            // Initialize buffer with 3 layers
            createBufferSections(3);
        }

        // Connect when page loads
        window.onload = function() {
            initializeDiagram();
            connectWebSocket();
            
            // Add event listener for test mode dropdown
            const testModeSelect = document.getElementById('testModeSelect');
            if (testModeSelect) {
                testModeSelect.addEventListener('change', function() {
                    console.log('Test mode changed to:', this.value);
                    // Trigger pipe color update with current snapshot data
                    if (window.lastSnapshotData) {
                        updatePipeColors(window.lastSnapshotData);
                    }
                });
            }
        };
    </script>
    </div>
</body>
</html>
